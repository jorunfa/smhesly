// This file is generated by rust-protobuf 2.13.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messagecore.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_13_0;

#[derive(PartialEq,Clone,Default)]
pub struct ReceiveMessagesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveMessagesRequest {
    fn default() -> &'a ReceiveMessagesRequest {
        <ReceiveMessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveMessagesRequest {
    pub fn new() -> ReceiveMessagesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReceiveMessagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveMessagesRequest {
        ReceiveMessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveMessagesRequest>(
                    "ReceiveMessagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReceiveMessagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReceiveMessagesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReceiveMessagesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReceiveMessagesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveMessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceiveTextMessagesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveTextMessagesRequest {
    fn default() -> &'a ReceiveTextMessagesRequest {
        <ReceiveTextMessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveTextMessagesRequest {
    pub fn new() -> ReceiveTextMessagesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReceiveTextMessagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveTextMessagesRequest {
        ReceiveTextMessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveTextMessagesRequest>(
                    "ReceiveTextMessagesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReceiveTextMessagesRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReceiveTextMessagesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReceiveTextMessagesRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReceiveTextMessagesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveTextMessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveTextMessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AckMessageResponse {
    // message fields
    pub ackResponseStatus: AckMessageResponse_AckResponseStatus,
    pub errorMessage: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckMessageResponse {
    fn default() -> &'a AckMessageResponse {
        <AckMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl AckMessageResponse {
    pub fn new() -> AckMessageResponse {
        ::std::default::Default::default()
    }

    // .messaging.AckMessageResponse.AckResponseStatus ackResponseStatus = 1;


    pub fn get_ackResponseStatus(&self) -> AckMessageResponse_AckResponseStatus {
        self.ackResponseStatus
    }
    pub fn clear_ackResponseStatus(&mut self) {
        self.ackResponseStatus = AckMessageResponse_AckResponseStatus::ACK_ACCEPTED;
    }

    // Param is passed by value, moved
    pub fn set_ackResponseStatus(&mut self, v: AckMessageResponse_AckResponseStatus) {
        self.ackResponseStatus = v;
    }

    // string errorMessage = 2;


    pub fn get_errorMessage(&self) -> &str {
        &self.errorMessage
    }
    pub fn clear_errorMessage(&mut self) {
        self.errorMessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage(&mut self) -> &mut ::std::string::String {
        &mut self.errorMessage
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errorMessage, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AckMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ackResponseStatus, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errorMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ackResponseStatus != AckMessageResponse_AckResponseStatus::ACK_ACCEPTED {
            my_size += ::protobuf::rt::enum_size(1, self.ackResponseStatus);
        }
        if !self.errorMessage.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errorMessage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ackResponseStatus != AckMessageResponse_AckResponseStatus::ACK_ACCEPTED {
            os.write_enum(1, self.ackResponseStatus.value())?;
        }
        if !self.errorMessage.is_empty() {
            os.write_string(2, &self.errorMessage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckMessageResponse {
        AckMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AckMessageResponse_AckResponseStatus>>(
                    "ackResponseStatus",
                    |m: &AckMessageResponse| { &m.ackResponseStatus },
                    |m: &mut AckMessageResponse| { &mut m.ackResponseStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "errorMessage",
                    |m: &AckMessageResponse| { &m.errorMessage },
                    |m: &mut AckMessageResponse| { &mut m.errorMessage },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AckMessageResponse>(
                    "AckMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AckMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<AckMessageResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AckMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for AckMessageResponse {
    fn clear(&mut self) {
        self.ackResponseStatus = AckMessageResponse_AckResponseStatus::ACK_ACCEPTED;
        self.errorMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AckMessageResponse_AckResponseStatus {
    ACK_ACCEPTED = 0,
    ACK_REJECTED = 1,
}

impl ::protobuf::ProtobufEnum for AckMessageResponse_AckResponseStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AckMessageResponse_AckResponseStatus> {
        match value {
            0 => ::std::option::Option::Some(AckMessageResponse_AckResponseStatus::ACK_ACCEPTED),
            1 => ::std::option::Option::Some(AckMessageResponse_AckResponseStatus::ACK_REJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AckMessageResponse_AckResponseStatus] = &[
            AckMessageResponse_AckResponseStatus::ACK_ACCEPTED,
            AckMessageResponse_AckResponseStatus::ACK_REJECTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<AckMessageResponse_AckResponseStatus>("AckMessageResponse.AckResponseStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AckMessageResponse_AckResponseStatus {
}

impl ::std::default::Default for AckMessageResponse_AckResponseStatus {
    fn default() -> Self {
        AckMessageResponse_AckResponseStatus::ACK_ACCEPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for AckMessageResponse_AckResponseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AckMessageRequest {
    // message fields
    pub ackStatus: ::protobuf::SingularPtrField<ReceiveStatus>,
    pub updatedMessage: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AckMessageRequest {
    fn default() -> &'a AckMessageRequest {
        <AckMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl AckMessageRequest {
    pub fn new() -> AckMessageRequest {
        ::std::default::Default::default()
    }

    // .messaging.ReceiveStatus ackStatus = 1;


    pub fn get_ackStatus(&self) -> &ReceiveStatus {
        self.ackStatus.as_ref().unwrap_or_else(|| ReceiveStatus::default_instance())
    }
    pub fn clear_ackStatus(&mut self) {
        self.ackStatus.clear();
    }

    pub fn has_ackStatus(&self) -> bool {
        self.ackStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ackStatus(&mut self, v: ReceiveStatus) {
        self.ackStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ackStatus(&mut self) -> &mut ReceiveStatus {
        if self.ackStatus.is_none() {
            self.ackStatus.set_default();
        }
        self.ackStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_ackStatus(&mut self) -> ReceiveStatus {
        self.ackStatus.take().unwrap_or_else(|| ReceiveStatus::new())
    }

    // .messaging.Message updatedMessage = 2;


    pub fn get_updatedMessage(&self) -> &Message {
        self.updatedMessage.as_ref().unwrap_or_else(|| Message::default_instance())
    }
    pub fn clear_updatedMessage(&mut self) {
        self.updatedMessage.clear();
    }

    pub fn has_updatedMessage(&self) -> bool {
        self.updatedMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatedMessage(&mut self, v: Message) {
        self.updatedMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updatedMessage(&mut self) -> &mut Message {
        if self.updatedMessage.is_none() {
            self.updatedMessage.set_default();
        }
        self.updatedMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_updatedMessage(&mut self) -> Message {
        self.updatedMessage.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for AckMessageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.ackStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updatedMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ackStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updatedMessage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ackStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updatedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ackStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updatedMessage.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AckMessageRequest {
        AckMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiveStatus>>(
                    "ackStatus",
                    |m: &AckMessageRequest| { &m.ackStatus },
                    |m: &mut AckMessageRequest| { &mut m.ackStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "updatedMessage",
                    |m: &AckMessageRequest| { &m.updatedMessage },
                    |m: &mut AckMessageRequest| { &mut m.updatedMessage },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AckMessageRequest>(
                    "AckMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AckMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<AckMessageRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AckMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for AckMessageRequest {
    fn clear(&mut self) {
        self.ackStatus.clear();
        self.updatedMessage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AckMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AckMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    pub field_type: Address_Type,
    pub number: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // .messaging.Address.Type type = 1;


    pub fn get_field_type(&self) -> Address_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Address_Type::TYPE_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Address_Type) {
        self.field_type = v;
    }

    // string number = 2;


    pub fn get_number(&self) -> &str {
        &self.number
    }
    pub fn clear_number(&mut self) {
        self.number.clear();
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: ::std::string::String) {
        self.number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_number(&mut self) -> &mut ::std::string::String {
        &mut self.number
    }

    // Take field
    pub fn take_number(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.number, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.number)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Address_Type::TYPE_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.number.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Address_Type::TYPE_NOT_SET {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.number.is_empty() {
            os.write_string(2, &self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Address_Type>>(
                    "type",
                    |m: &Address| { &m.field_type },
                    |m: &mut Address| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "number",
                    |m: &Address| { &m.number },
                    |m: &mut Address| { &mut m.number },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Address::new)
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.field_type = Address_Type::TYPE_NOT_SET;
        self.number.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Address_Type {
    TYPE_NOT_SET = 0,
    UNKNOWN = 1,
    INTERNATIONAL_NUMBER = 2,
    NATIONAL_NUMBER = 3,
    TEXT = 4,
    EMAIL = 5,
    IMSI = 6,
    RESERVED = 7,
}

impl ::protobuf::ProtobufEnum for Address_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Address_Type> {
        match value {
            0 => ::std::option::Option::Some(Address_Type::TYPE_NOT_SET),
            1 => ::std::option::Option::Some(Address_Type::UNKNOWN),
            2 => ::std::option::Option::Some(Address_Type::INTERNATIONAL_NUMBER),
            3 => ::std::option::Option::Some(Address_Type::NATIONAL_NUMBER),
            4 => ::std::option::Option::Some(Address_Type::TEXT),
            5 => ::std::option::Option::Some(Address_Type::EMAIL),
            6 => ::std::option::Option::Some(Address_Type::IMSI),
            7 => ::std::option::Option::Some(Address_Type::RESERVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Address_Type] = &[
            Address_Type::TYPE_NOT_SET,
            Address_Type::UNKNOWN,
            Address_Type::INTERNATIONAL_NUMBER,
            Address_Type::NATIONAL_NUMBER,
            Address_Type::TEXT,
            Address_Type::EMAIL,
            Address_Type::IMSI,
            Address_Type::RESERVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Address_Type>("Address.Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Address_Type {
}

impl ::std::default::Default for Address_Type {
    fn default() -> Self {
        Address_Type::TYPE_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for Address_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageBox {
    // message fields
    pub forAddress: ::protobuf::SingularPtrField<Address>,
    pub direction: MessageBox_BoxDirection,
    pub messages: ::protobuf::RepeatedField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageBox {
    fn default() -> &'a MessageBox {
        <MessageBox as ::protobuf::Message>::default_instance()
    }
}

impl MessageBox {
    pub fn new() -> MessageBox {
        ::std::default::Default::default()
    }

    // .messaging.Address forAddress = 1;


    pub fn get_forAddress(&self) -> &Address {
        self.forAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_forAddress(&mut self) {
        self.forAddress.clear();
    }

    pub fn has_forAddress(&self) -> bool {
        self.forAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forAddress(&mut self, v: Address) {
        self.forAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forAddress(&mut self) -> &mut Address {
        if self.forAddress.is_none() {
            self.forAddress.set_default();
        }
        self.forAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_forAddress(&mut self) -> Address {
        self.forAddress.take().unwrap_or_else(|| Address::new())
    }

    // .messaging.MessageBox.BoxDirection direction = 2;


    pub fn get_direction(&self) -> MessageBox_BoxDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: MessageBox_BoxDirection) {
        self.direction = v;
    }

    // repeated .messaging.Message messages = 3;


    pub fn get_messages(&self) -> &[Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessageBox {
    fn is_initialized(&self) -> bool {
        for v in &self.forAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.forAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET {
            my_size += ::protobuf::rt::enum_size(2, self.direction);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.forAddress.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET {
            os.write_enum(2, self.direction.value())?;
        }
        for v in &self.messages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageBox {
        MessageBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "forAddress",
                    |m: &MessageBox| { &m.forAddress },
                    |m: &mut MessageBox| { &mut m.forAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageBox_BoxDirection>>(
                    "direction",
                    |m: &MessageBox| { &m.direction },
                    |m: &mut MessageBox| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                    "messages",
                    |m: &MessageBox| { &m.messages },
                    |m: &mut MessageBox| { &mut m.messages },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageBox>(
                    "MessageBox",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageBox {
        static mut instance: ::protobuf::lazy::Lazy<MessageBox> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageBox::new)
        }
    }
}

impl ::protobuf::Clear for MessageBox {
    fn clear(&mut self) {
        self.forAddress.clear();
        self.direction = MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET;
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageBox_BoxDirection {
    BOX_DIRECTION_NOT_SET = 0,
    INCOMING = 1,
    OUTGOING = 2,
    BOTH = 3,
}

impl ::protobuf::ProtobufEnum for MessageBox_BoxDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageBox_BoxDirection> {
        match value {
            0 => ::std::option::Option::Some(MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET),
            1 => ::std::option::Option::Some(MessageBox_BoxDirection::INCOMING),
            2 => ::std::option::Option::Some(MessageBox_BoxDirection::OUTGOING),
            3 => ::std::option::Option::Some(MessageBox_BoxDirection::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageBox_BoxDirection] = &[
            MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET,
            MessageBox_BoxDirection::INCOMING,
            MessageBox_BoxDirection::OUTGOING,
            MessageBox_BoxDirection::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<MessageBox_BoxDirection>("MessageBox.BoxDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageBox_BoxDirection {
}

impl ::std::default::Default for MessageBox_BoxDirection {
    fn default() -> Self {
        MessageBox_BoxDirection::BOX_DIRECTION_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageBox_BoxDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextMessageBox {
    // message fields
    pub forAddress: ::protobuf::SingularPtrField<Address>,
    pub textMessages: ::protobuf::RepeatedField<TextMessage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextMessageBox {
    fn default() -> &'a TextMessageBox {
        <TextMessageBox as ::protobuf::Message>::default_instance()
    }
}

impl TextMessageBox {
    pub fn new() -> TextMessageBox {
        ::std::default::Default::default()
    }

    // .messaging.Address forAddress = 1;


    pub fn get_forAddress(&self) -> &Address {
        self.forAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_forAddress(&mut self) {
        self.forAddress.clear();
    }

    pub fn has_forAddress(&self) -> bool {
        self.forAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forAddress(&mut self, v: Address) {
        self.forAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forAddress(&mut self) -> &mut Address {
        if self.forAddress.is_none() {
            self.forAddress.set_default();
        }
        self.forAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_forAddress(&mut self) -> Address {
        self.forAddress.take().unwrap_or_else(|| Address::new())
    }

    // repeated .messaging.TextMessage textMessages = 3;


    pub fn get_textMessages(&self) -> &[TextMessage] {
        &self.textMessages
    }
    pub fn clear_textMessages(&mut self) {
        self.textMessages.clear();
    }

    // Param is passed by value, moved
    pub fn set_textMessages(&mut self, v: ::protobuf::RepeatedField<TextMessage>) {
        self.textMessages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_textMessages(&mut self) -> &mut ::protobuf::RepeatedField<TextMessage> {
        &mut self.textMessages
    }

    // Take field
    pub fn take_textMessages(&mut self) -> ::protobuf::RepeatedField<TextMessage> {
        ::std::mem::replace(&mut self.textMessages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TextMessageBox {
    fn is_initialized(&self) -> bool {
        for v in &self.forAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.textMessages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.textMessages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.forAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.textMessages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.forAddress.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.textMessages {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextMessageBox {
        TextMessageBox::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "forAddress",
                    |m: &TextMessageBox| { &m.forAddress },
                    |m: &mut TextMessageBox| { &mut m.forAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextMessage>>(
                    "textMessages",
                    |m: &TextMessageBox| { &m.textMessages },
                    |m: &mut TextMessageBox| { &mut m.textMessages },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextMessageBox>(
                    "TextMessageBox",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TextMessageBox {
        static mut instance: ::protobuf::lazy::Lazy<TextMessageBox> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TextMessageBox::new)
        }
    }
}

impl ::protobuf::Clear for TextMessageBox {
    fn clear(&mut self) {
        self.forAddress.clear();
        self.textMessages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextMessageBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessageBox {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub messageId: i64,
    pub fragments: ::protobuf::SingularPtrField<SmsFragmentedContent>,
    pub fromAddress: ::protobuf::SingularPtrField<Address>,
    pub toAddress: ::protobuf::SingularPtrField<Address>,
    pub direction: Direction,
    pub expires: u64,
    pub producer: ::std::string::String,
    pub sendTimestamp: u64,
    pub route: ::protobuf::SingularPtrField<MessageRoute>,
    pub routingState: ::protobuf::RepeatedField<Message_RoutingState>,
    pub uuid: ::std::string::String,
    pub originNetworkNode: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // int64 messageId = 1;


    pub fn get_messageId(&self) -> i64 {
        self.messageId
    }
    pub fn clear_messageId(&mut self) {
        self.messageId = 0;
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = v;
    }

    // .messaging.SmsFragmentedContent fragments = 2;


    pub fn get_fragments(&self) -> &SmsFragmentedContent {
        self.fragments.as_ref().unwrap_or_else(|| SmsFragmentedContent::default_instance())
    }
    pub fn clear_fragments(&mut self) {
        self.fragments.clear();
    }

    pub fn has_fragments(&self) -> bool {
        self.fragments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragments(&mut self, v: SmsFragmentedContent) {
        self.fragments = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fragments(&mut self) -> &mut SmsFragmentedContent {
        if self.fragments.is_none() {
            self.fragments.set_default();
        }
        self.fragments.as_mut().unwrap()
    }

    // Take field
    pub fn take_fragments(&mut self) -> SmsFragmentedContent {
        self.fragments.take().unwrap_or_else(|| SmsFragmentedContent::new())
    }

    // .messaging.Address fromAddress = 3;


    pub fn get_fromAddress(&self) -> &Address {
        self.fromAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_fromAddress(&mut self) {
        self.fromAddress.clear();
    }

    pub fn has_fromAddress(&self) -> bool {
        self.fromAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromAddress(&mut self, v: Address) {
        self.fromAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromAddress(&mut self) -> &mut Address {
        if self.fromAddress.is_none() {
            self.fromAddress.set_default();
        }
        self.fromAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromAddress(&mut self) -> Address {
        self.fromAddress.take().unwrap_or_else(|| Address::new())
    }

    // .messaging.Address toAddress = 4;


    pub fn get_toAddress(&self) -> &Address {
        self.toAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    pub fn has_toAddress(&self) -> bool {
        self.toAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: Address) {
        self.toAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut Address {
        if self.toAddress.is_none() {
            self.toAddress.set_default();
        }
        self.toAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_toAddress(&mut self) -> Address {
        self.toAddress.take().unwrap_or_else(|| Address::new())
    }

    // .messaging.Direction direction = 5;


    pub fn get_direction(&self) -> Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = Direction::DIRECTION_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: Direction) {
        self.direction = v;
    }

    // uint64 expires = 6;


    pub fn get_expires(&self) -> u64 {
        self.expires
    }
    pub fn clear_expires(&mut self) {
        self.expires = 0;
    }

    // Param is passed by value, moved
    pub fn set_expires(&mut self, v: u64) {
        self.expires = v;
    }

    // string producer = 7;


    pub fn get_producer(&self) -> &str {
        &self.producer
    }
    pub fn clear_producer(&mut self) {
        self.producer.clear();
    }

    // Param is passed by value, moved
    pub fn set_producer(&mut self, v: ::std::string::String) {
        self.producer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_producer(&mut self) -> &mut ::std::string::String {
        &mut self.producer
    }

    // Take field
    pub fn take_producer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.producer, ::std::string::String::new())
    }

    // uint64 sendTimestamp = 9;


    pub fn get_sendTimestamp(&self) -> u64 {
        self.sendTimestamp
    }
    pub fn clear_sendTimestamp(&mut self) {
        self.sendTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_sendTimestamp(&mut self, v: u64) {
        self.sendTimestamp = v;
    }

    // .messaging.MessageRoute route = 10;


    pub fn get_route(&self) -> &MessageRoute {
        self.route.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: MessageRoute) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut MessageRoute {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> MessageRoute {
        self.route.take().unwrap_or_else(|| MessageRoute::new())
    }

    // repeated .messaging.Message.RoutingState routingState = 11;


    pub fn get_routingState(&self) -> &[Message_RoutingState] {
        &self.routingState
    }
    pub fn clear_routingState(&mut self) {
        self.routingState.clear();
    }

    // Param is passed by value, moved
    pub fn set_routingState(&mut self, v: ::protobuf::RepeatedField<Message_RoutingState>) {
        self.routingState = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routingState(&mut self) -> &mut ::protobuf::RepeatedField<Message_RoutingState> {
        &mut self.routingState
    }

    // Take field
    pub fn take_routingState(&mut self) -> ::protobuf::RepeatedField<Message_RoutingState> {
        ::std::mem::replace(&mut self.routingState, ::protobuf::RepeatedField::new())
    }

    // string uuid = 12;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    // .messaging.Address originNetworkNode = 13;


    pub fn get_originNetworkNode(&self) -> &Address {
        self.originNetworkNode.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_originNetworkNode(&mut self) {
        self.originNetworkNode.clear();
    }

    pub fn has_originNetworkNode(&self) -> bool {
        self.originNetworkNode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originNetworkNode(&mut self, v: Address) {
        self.originNetworkNode = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originNetworkNode(&mut self) -> &mut Address {
        if self.originNetworkNode.is_none() {
            self.originNetworkNode.set_default();
        }
        self.originNetworkNode.as_mut().unwrap()
    }

    // Take field
    pub fn take_originNetworkNode(&mut self) -> Address {
        self.originNetworkNode.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.fragments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fromAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.toAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routingState {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.originNetworkNode {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.messageId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fragments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fromAddress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.toAddress)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expires = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.producer)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sendTimestamp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routingState)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.originNetworkNode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.messageId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.messageId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fragments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fromAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.toAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != Direction::DIRECTION_NOT_SET {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        if self.expires != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expires, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.producer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.producer);
        }
        if self.sendTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.sendTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.routingState {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.uuid);
        }
        if let Some(ref v) = self.originNetworkNode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.messageId != 0 {
            os.write_int64(1, self.messageId)?;
        }
        if let Some(ref v) = self.fragments.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fromAddress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.toAddress.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != Direction::DIRECTION_NOT_SET {
            os.write_enum(5, self.direction.value())?;
        }
        if self.expires != 0 {
            os.write_uint64(6, self.expires)?;
        }
        if !self.producer.is_empty() {
            os.write_string(7, &self.producer)?;
        }
        if self.sendTimestamp != 0 {
            os.write_uint64(9, self.sendTimestamp)?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.routingState {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.uuid.is_empty() {
            os.write_string(12, &self.uuid)?;
        }
        if let Some(ref v) = self.originNetworkNode.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "messageId",
                    |m: &Message| { &m.messageId },
                    |m: &mut Message| { &mut m.messageId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmsFragmentedContent>>(
                    "fragments",
                    |m: &Message| { &m.fragments },
                    |m: &mut Message| { &mut m.fragments },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "fromAddress",
                    |m: &Message| { &m.fromAddress },
                    |m: &mut Message| { &mut m.fromAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "toAddress",
                    |m: &Message| { &m.toAddress },
                    |m: &mut Message| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                    "direction",
                    |m: &Message| { &m.direction },
                    |m: &mut Message| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "expires",
                    |m: &Message| { &m.expires },
                    |m: &mut Message| { &mut m.expires },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "producer",
                    |m: &Message| { &m.producer },
                    |m: &mut Message| { &mut m.producer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sendTimestamp",
                    |m: &Message| { &m.sendTimestamp },
                    |m: &mut Message| { &mut m.sendTimestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "route",
                    |m: &Message| { &m.route },
                    |m: &mut Message| { &mut m.route },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message_RoutingState>>(
                    "routingState",
                    |m: &Message| { &m.routingState },
                    |m: &mut Message| { &mut m.routingState },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uuid",
                    |m: &Message| { &m.uuid },
                    |m: &mut Message| { &mut m.uuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "originNetworkNode",
                    |m: &Message| { &m.originNetworkNode },
                    |m: &mut Message| { &mut m.originNetworkNode },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Message>(
                    "Message",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message {
        static mut instance: ::protobuf::lazy::Lazy<Message> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Message::new)
        }
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.messageId = 0;
        self.fragments.clear();
        self.fromAddress.clear();
        self.toAddress.clear();
        self.direction = Direction::DIRECTION_NOT_SET;
        self.expires = 0;
        self.producer.clear();
        self.sendTimestamp = 0;
        self.route.clear();
        self.routingState.clear();
        self.uuid.clear();
        self.originNetworkNode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message_RoutingState {
    // message oneof groups
    pub alt: ::std::option::Option<Message_RoutingState_oneof_alt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message_RoutingState {
    fn default() -> &'a Message_RoutingState {
        <Message_RoutingState as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Message_RoutingState_oneof_alt {
    receiveAttempt(ReceiveAttemptStatus),
    takenChoice(i32),
    takenFork(i32),
}

impl Message_RoutingState {
    pub fn new() -> Message_RoutingState {
        ::std::default::Default::default()
    }

    // .messaging.ReceiveAttemptStatus receiveAttempt = 1;


    pub fn get_receiveAttempt(&self) -> ReceiveAttemptStatus {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::receiveAttempt(v)) => v,
            _ => ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET,
        }
    }
    pub fn clear_receiveAttempt(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_receiveAttempt(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::receiveAttempt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_receiveAttempt(&mut self, v: ReceiveAttemptStatus) {
        self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::receiveAttempt(v))
    }

    // sint32 takenChoice = 2;


    pub fn get_takenChoice(&self) -> i32 {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenChoice(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_takenChoice(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_takenChoice(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenChoice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_takenChoice(&mut self, v: i32) {
        self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenChoice(v))
    }

    // sint32 takenFork = 3;


    pub fn get_takenFork(&self) -> i32 {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenFork(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_takenFork(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_takenFork(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenFork(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_takenFork(&mut self, v: i32) {
        self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenFork(v))
    }
}

impl ::protobuf::Message for Message_RoutingState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::receiveAttempt(is.read_enum()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenChoice(is.read_sint32()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(Message_RoutingState_oneof_alt::takenFork(is.read_sint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.alt {
            match v {
                &Message_RoutingState_oneof_alt::receiveAttempt(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
                &Message_RoutingState_oneof_alt::takenChoice(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
                },
                &Message_RoutingState_oneof_alt::takenFork(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.alt {
            match v {
                &Message_RoutingState_oneof_alt::receiveAttempt(v) => {
                    os.write_enum(1, v.value())?;
                },
                &Message_RoutingState_oneof_alt::takenChoice(v) => {
                    os.write_sint32(2, v)?;
                },
                &Message_RoutingState_oneof_alt::takenFork(v) => {
                    os.write_sint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message_RoutingState {
        Message_RoutingState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ReceiveAttemptStatus>(
                    "receiveAttempt",
                    Message_RoutingState::has_receiveAttempt,
                    Message_RoutingState::get_receiveAttempt,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "takenChoice",
                    Message_RoutingState::has_takenChoice,
                    Message_RoutingState::get_takenChoice,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "takenFork",
                    Message_RoutingState::has_takenFork,
                    Message_RoutingState::get_takenFork,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Message_RoutingState>(
                    "Message.RoutingState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Message_RoutingState {
        static mut instance: ::protobuf::lazy::Lazy<Message_RoutingState> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Message_RoutingState::new)
        }
    }
}

impl ::protobuf::Clear for Message_RoutingState {
    fn clear(&mut self) {
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message_RoutingState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message_RoutingState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute {
    // message oneof groups
    pub route: ::std::option::Option<MessageRoute_oneof_route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute {
    fn default() -> &'a MessageRoute {
        <MessageRoute as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MessageRoute_oneof_route {
    rejecting(MessageRoute_RejectingRoute),
    retrying(MessageRoute_RetryingRoute),
    field_static(MessageRoute_StaticRoute),
    destinationRewrite(MessageRoute_DestinationRewrite),
    thenDo(MessageRoute_ThenDo),
    choice(MessageRoute_Choice),
    fork(MessageRoute_Fork),
}

impl MessageRoute {
    pub fn new() -> MessageRoute {
        ::std::default::Default::default()
    }

    // .messaging.MessageRoute.RejectingRoute rejecting = 1;


    pub fn get_rejecting(&self) -> &MessageRoute_RejectingRoute {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(ref v)) => v,
            _ => MessageRoute_RejectingRoute::default_instance(),
        }
    }
    pub fn clear_rejecting(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_rejecting(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rejecting(&mut self, v: MessageRoute_RejectingRoute) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rejecting(&mut self) -> &mut MessageRoute_RejectingRoute {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(MessageRoute_RejectingRoute::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rejecting(&mut self) -> MessageRoute_RejectingRoute {
        if self.has_rejecting() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_RejectingRoute::new()
        }
    }

    // .messaging.MessageRoute.RetryingRoute retrying = 2;


    pub fn get_retrying(&self) -> &MessageRoute_RetryingRoute {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::retrying(ref v)) => v,
            _ => MessageRoute_RetryingRoute::default_instance(),
        }
    }
    pub fn clear_retrying(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_retrying(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::retrying(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_retrying(&mut self, v: MessageRoute_RetryingRoute) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::retrying(v))
    }

    // Mutable pointer to the field.
    pub fn mut_retrying(&mut self) -> &mut MessageRoute_RetryingRoute {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::retrying(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::retrying(MessageRoute_RetryingRoute::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::retrying(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_retrying(&mut self) -> MessageRoute_RetryingRoute {
        if self.has_retrying() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::retrying(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_RetryingRoute::new()
        }
    }

    // .messaging.MessageRoute.StaticRoute static = 3;


    pub fn get_field_static(&self) -> &MessageRoute_StaticRoute {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::field_static(ref v)) => v,
            _ => MessageRoute_StaticRoute::default_instance(),
        }
    }
    pub fn clear_field_static(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_field_static(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::field_static(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_static(&mut self, v: MessageRoute_StaticRoute) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::field_static(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_static(&mut self) -> &mut MessageRoute_StaticRoute {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::field_static(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::field_static(MessageRoute_StaticRoute::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::field_static(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_static(&mut self) -> MessageRoute_StaticRoute {
        if self.has_field_static() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::field_static(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_StaticRoute::new()
        }
    }

    // .messaging.MessageRoute.DestinationRewrite destinationRewrite = 4;


    pub fn get_destinationRewrite(&self) -> &MessageRoute_DestinationRewrite {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(ref v)) => v,
            _ => MessageRoute_DestinationRewrite::default_instance(),
        }
    }
    pub fn clear_destinationRewrite(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_destinationRewrite(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destinationRewrite(&mut self, v: MessageRoute_DestinationRewrite) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destinationRewrite(&mut self) -> &mut MessageRoute_DestinationRewrite {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(MessageRoute_DestinationRewrite::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destinationRewrite(&mut self) -> MessageRoute_DestinationRewrite {
        if self.has_destinationRewrite() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_DestinationRewrite::new()
        }
    }

    // .messaging.MessageRoute.ThenDo thenDo = 5;


    pub fn get_thenDo(&self) -> &MessageRoute_ThenDo {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(ref v)) => v,
            _ => MessageRoute_ThenDo::default_instance(),
        }
    }
    pub fn clear_thenDo(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_thenDo(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thenDo(&mut self, v: MessageRoute_ThenDo) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thenDo(&mut self) -> &mut MessageRoute_ThenDo {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(MessageRoute_ThenDo::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thenDo(&mut self) -> MessageRoute_ThenDo {
        if self.has_thenDo() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_ThenDo::new()
        }
    }

    // .messaging.MessageRoute.Choice choice = 6;


    pub fn get_choice(&self) -> &MessageRoute_Choice {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::choice(ref v)) => v,
            _ => MessageRoute_Choice::default_instance(),
        }
    }
    pub fn clear_choice(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_choice(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::choice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: MessageRoute_Choice) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::choice(v))
    }

    // Mutable pointer to the field.
    pub fn mut_choice(&mut self) -> &mut MessageRoute_Choice {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::choice(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::choice(MessageRoute_Choice::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::choice(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_choice(&mut self) -> MessageRoute_Choice {
        if self.has_choice() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::choice(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_Choice::new()
        }
    }

    // .messaging.MessageRoute.Fork fork = 7;


    pub fn get_fork(&self) -> &MessageRoute_Fork {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::fork(ref v)) => v,
            _ => MessageRoute_Fork::default_instance(),
        }
    }
    pub fn clear_fork(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_fork(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::fork(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fork(&mut self, v: MessageRoute_Fork) {
        self.route = ::std::option::Option::Some(MessageRoute_oneof_route::fork(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fork(&mut self) -> &mut MessageRoute_Fork {
        if let ::std::option::Option::Some(MessageRoute_oneof_route::fork(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MessageRoute_oneof_route::fork(MessageRoute_Fork::new()));
        }
        match self.route {
            ::std::option::Option::Some(MessageRoute_oneof_route::fork(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fork(&mut self) -> MessageRoute_Fork {
        if self.has_fork() {
            match self.route.take() {
                ::std::option::Option::Some(MessageRoute_oneof_route::fork(v)) => v,
                _ => panic!(),
            }
        } else {
            MessageRoute_Fork::new()
        }
    }
}

impl ::protobuf::Message for MessageRoute {
    fn is_initialized(&self) -> bool {
        if let Some(MessageRoute_oneof_route::rejecting(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::retrying(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::field_static(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::destinationRewrite(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::thenDo(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::choice(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MessageRoute_oneof_route::fork(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::rejecting(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::retrying(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::field_static(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::destinationRewrite(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::thenDo(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::choice(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MessageRoute_oneof_route::fork(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.route {
            match v {
                &MessageRoute_oneof_route::rejecting(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::retrying(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::field_static(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::destinationRewrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::thenDo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::choice(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MessageRoute_oneof_route::fork(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.route {
            match v {
                &MessageRoute_oneof_route::rejecting(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::retrying(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::field_static(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::destinationRewrite(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::thenDo(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::choice(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MessageRoute_oneof_route::fork(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute {
        MessageRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_RejectingRoute>(
                    "rejecting",
                    MessageRoute::has_rejecting,
                    MessageRoute::get_rejecting,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_RetryingRoute>(
                    "retrying",
                    MessageRoute::has_retrying,
                    MessageRoute::get_retrying,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_StaticRoute>(
                    "static",
                    MessageRoute::has_field_static,
                    MessageRoute::get_field_static,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_DestinationRewrite>(
                    "destinationRewrite",
                    MessageRoute::has_destinationRewrite,
                    MessageRoute::get_destinationRewrite,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_ThenDo>(
                    "thenDo",
                    MessageRoute::has_thenDo,
                    MessageRoute::get_thenDo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_Choice>(
                    "choice",
                    MessageRoute::has_choice,
                    MessageRoute::get_choice,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MessageRoute_Fork>(
                    "fork",
                    MessageRoute::has_fork,
                    MessageRoute::get_fork,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute>(
                    "MessageRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute {
    fn clear(&mut self) {
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_RejectingRoute {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_RejectingRoute {
    fn default() -> &'a MessageRoute_RejectingRoute {
        <MessageRoute_RejectingRoute as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_RejectingRoute {
    pub fn new() -> MessageRoute_RejectingRoute {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MessageRoute_RejectingRoute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_RejectingRoute {
        MessageRoute_RejectingRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_RejectingRoute>(
                    "MessageRoute.RejectingRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_RejectingRoute {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_RejectingRoute> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_RejectingRoute::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_RejectingRoute {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_RejectingRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_RejectingRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_RetryingRoute {
    // message fields
    pub subRoute: ::protobuf::SingularPtrField<MessageRoute>,
    pub maxAttemptsBeforeFail: i32,
    pub errorBackoff: ::protobuf::SingularPtrField<MessageRoute_RetryingRoute_BackoffParameters>,
    pub errorsToRetry: ::std::vec::Vec<ReceiveAttemptStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_RetryingRoute {
    fn default() -> &'a MessageRoute_RetryingRoute {
        <MessageRoute_RetryingRoute as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_RetryingRoute {
    pub fn new() -> MessageRoute_RetryingRoute {
        ::std::default::Default::default()
    }

    // .messaging.MessageRoute subRoute = 1;


    pub fn get_subRoute(&self) -> &MessageRoute {
        self.subRoute.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_subRoute(&mut self) {
        self.subRoute.clear();
    }

    pub fn has_subRoute(&self) -> bool {
        self.subRoute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subRoute(&mut self, v: MessageRoute) {
        self.subRoute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subRoute(&mut self) -> &mut MessageRoute {
        if self.subRoute.is_none() {
            self.subRoute.set_default();
        }
        self.subRoute.as_mut().unwrap()
    }

    // Take field
    pub fn take_subRoute(&mut self) -> MessageRoute {
        self.subRoute.take().unwrap_or_else(|| MessageRoute::new())
    }

    // int32 maxAttemptsBeforeFail = 2;


    pub fn get_maxAttemptsBeforeFail(&self) -> i32 {
        self.maxAttemptsBeforeFail
    }
    pub fn clear_maxAttemptsBeforeFail(&mut self) {
        self.maxAttemptsBeforeFail = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxAttemptsBeforeFail(&mut self, v: i32) {
        self.maxAttemptsBeforeFail = v;
    }

    // .messaging.MessageRoute.RetryingRoute.BackoffParameters errorBackoff = 3;


    pub fn get_errorBackoff(&self) -> &MessageRoute_RetryingRoute_BackoffParameters {
        self.errorBackoff.as_ref().unwrap_or_else(|| MessageRoute_RetryingRoute_BackoffParameters::default_instance())
    }
    pub fn clear_errorBackoff(&mut self) {
        self.errorBackoff.clear();
    }

    pub fn has_errorBackoff(&self) -> bool {
        self.errorBackoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorBackoff(&mut self, v: MessageRoute_RetryingRoute_BackoffParameters) {
        self.errorBackoff = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorBackoff(&mut self) -> &mut MessageRoute_RetryingRoute_BackoffParameters {
        if self.errorBackoff.is_none() {
            self.errorBackoff.set_default();
        }
        self.errorBackoff.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorBackoff(&mut self) -> MessageRoute_RetryingRoute_BackoffParameters {
        self.errorBackoff.take().unwrap_or_else(|| MessageRoute_RetryingRoute_BackoffParameters::new())
    }

    // repeated .messaging.ReceiveAttemptStatus errorsToRetry = 4;


    pub fn get_errorsToRetry(&self) -> &[ReceiveAttemptStatus] {
        &self.errorsToRetry
    }
    pub fn clear_errorsToRetry(&mut self) {
        self.errorsToRetry.clear();
    }

    // Param is passed by value, moved
    pub fn set_errorsToRetry(&mut self, v: ::std::vec::Vec<ReceiveAttemptStatus>) {
        self.errorsToRetry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_errorsToRetry(&mut self) -> &mut ::std::vec::Vec<ReceiveAttemptStatus> {
        &mut self.errorsToRetry
    }

    // Take field
    pub fn take_errorsToRetry(&mut self) -> ::std::vec::Vec<ReceiveAttemptStatus> {
        ::std::mem::replace(&mut self.errorsToRetry, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MessageRoute_RetryingRoute {
    fn is_initialized(&self) -> bool {
        for v in &self.subRoute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.errorBackoff {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subRoute)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxAttemptsBeforeFail = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.errorBackoff)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.errorsToRetry, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subRoute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.maxAttemptsBeforeFail != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maxAttemptsBeforeFail, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.errorBackoff.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.errorsToRetry {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subRoute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.maxAttemptsBeforeFail != 0 {
            os.write_int32(2, self.maxAttemptsBeforeFail)?;
        }
        if let Some(ref v) = self.errorBackoff.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.errorsToRetry {
            os.write_enum(4, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_RetryingRoute {
        MessageRoute_RetryingRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "subRoute",
                    |m: &MessageRoute_RetryingRoute| { &m.subRoute },
                    |m: &mut MessageRoute_RetryingRoute| { &mut m.subRoute },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maxAttemptsBeforeFail",
                    |m: &MessageRoute_RetryingRoute| { &m.maxAttemptsBeforeFail },
                    |m: &mut MessageRoute_RetryingRoute| { &mut m.maxAttemptsBeforeFail },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute_RetryingRoute_BackoffParameters>>(
                    "errorBackoff",
                    |m: &MessageRoute_RetryingRoute| { &m.errorBackoff },
                    |m: &mut MessageRoute_RetryingRoute| { &mut m.errorBackoff },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReceiveAttemptStatus>>(
                    "errorsToRetry",
                    |m: &MessageRoute_RetryingRoute| { &m.errorsToRetry },
                    |m: &mut MessageRoute_RetryingRoute| { &mut m.errorsToRetry },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_RetryingRoute>(
                    "MessageRoute.RetryingRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_RetryingRoute {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_RetryingRoute> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_RetryingRoute::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_RetryingRoute {
    fn clear(&mut self) {
        self.subRoute.clear();
        self.maxAttemptsBeforeFail = 0;
        self.errorBackoff.clear();
        self.errorsToRetry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_RetryingRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_RetryingRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_RetryingRoute_BackoffParameters {
    // message fields
    pub backoffIntervalSeconds: i32,
    pub maxBackoffPower: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_RetryingRoute_BackoffParameters {
    fn default() -> &'a MessageRoute_RetryingRoute_BackoffParameters {
        <MessageRoute_RetryingRoute_BackoffParameters as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_RetryingRoute_BackoffParameters {
    pub fn new() -> MessageRoute_RetryingRoute_BackoffParameters {
        ::std::default::Default::default()
    }

    // int32 backoffIntervalSeconds = 1;


    pub fn get_backoffIntervalSeconds(&self) -> i32 {
        self.backoffIntervalSeconds
    }
    pub fn clear_backoffIntervalSeconds(&mut self) {
        self.backoffIntervalSeconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_backoffIntervalSeconds(&mut self, v: i32) {
        self.backoffIntervalSeconds = v;
    }

    // int32 maxBackoffPower = 2;


    pub fn get_maxBackoffPower(&self) -> i32 {
        self.maxBackoffPower
    }
    pub fn clear_maxBackoffPower(&mut self) {
        self.maxBackoffPower = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxBackoffPower(&mut self, v: i32) {
        self.maxBackoffPower = v;
    }
}

impl ::protobuf::Message for MessageRoute_RetryingRoute_BackoffParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backoffIntervalSeconds = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxBackoffPower = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.backoffIntervalSeconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.backoffIntervalSeconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxBackoffPower != 0 {
            my_size += ::protobuf::rt::value_size(2, self.maxBackoffPower, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.backoffIntervalSeconds != 0 {
            os.write_int32(1, self.backoffIntervalSeconds)?;
        }
        if self.maxBackoffPower != 0 {
            os.write_int32(2, self.maxBackoffPower)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_RetryingRoute_BackoffParameters {
        MessageRoute_RetryingRoute_BackoffParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "backoffIntervalSeconds",
                    |m: &MessageRoute_RetryingRoute_BackoffParameters| { &m.backoffIntervalSeconds },
                    |m: &mut MessageRoute_RetryingRoute_BackoffParameters| { &mut m.backoffIntervalSeconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "maxBackoffPower",
                    |m: &MessageRoute_RetryingRoute_BackoffParameters| { &m.maxBackoffPower },
                    |m: &mut MessageRoute_RetryingRoute_BackoffParameters| { &mut m.maxBackoffPower },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_RetryingRoute_BackoffParameters>(
                    "MessageRoute.RetryingRoute.BackoffParameters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_RetryingRoute_BackoffParameters {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_RetryingRoute_BackoffParameters> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_RetryingRoute_BackoffParameters::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_RetryingRoute_BackoffParameters {
    fn clear(&mut self) {
        self.backoffIntervalSeconds = 0;
        self.maxBackoffPower = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_RetryingRoute_BackoffParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_RetryingRoute_BackoffParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_StaticRoute {
    // message fields
    pub consumer: ::std::string::String,
    pub receiveTimeout: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_StaticRoute {
    fn default() -> &'a MessageRoute_StaticRoute {
        <MessageRoute_StaticRoute as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_StaticRoute {
    pub fn new() -> MessageRoute_StaticRoute {
        ::std::default::Default::default()
    }

    // string consumer = 1;


    pub fn get_consumer(&self) -> &str {
        &self.consumer
    }
    pub fn clear_consumer(&mut self) {
        self.consumer.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumer(&mut self, v: ::std::string::String) {
        self.consumer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumer(&mut self) -> &mut ::std::string::String {
        &mut self.consumer
    }

    // Take field
    pub fn take_consumer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.consumer, ::std::string::String::new())
    }

    // int32 receiveTimeout = 2;


    pub fn get_receiveTimeout(&self) -> i32 {
        self.receiveTimeout
    }
    pub fn clear_receiveTimeout(&mut self) {
        self.receiveTimeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_receiveTimeout(&mut self, v: i32) {
        self.receiveTimeout = v;
    }
}

impl ::protobuf::Message for MessageRoute_StaticRoute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.consumer)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.receiveTimeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.consumer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.consumer);
        }
        if self.receiveTimeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.receiveTimeout, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.consumer.is_empty() {
            os.write_string(1, &self.consumer)?;
        }
        if self.receiveTimeout != 0 {
            os.write_int32(2, self.receiveTimeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_StaticRoute {
        MessageRoute_StaticRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "consumer",
                    |m: &MessageRoute_StaticRoute| { &m.consumer },
                    |m: &mut MessageRoute_StaticRoute| { &mut m.consumer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "receiveTimeout",
                    |m: &MessageRoute_StaticRoute| { &m.receiveTimeout },
                    |m: &mut MessageRoute_StaticRoute| { &mut m.receiveTimeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_StaticRoute>(
                    "MessageRoute.StaticRoute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_StaticRoute {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_StaticRoute> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_StaticRoute::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_StaticRoute {
    fn clear(&mut self) {
        self.consumer.clear();
        self.receiveTimeout = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_StaticRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_StaticRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_DestinationRewrite {
    // message fields
    pub newAddress: ::protobuf::SingularPtrField<Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_DestinationRewrite {
    fn default() -> &'a MessageRoute_DestinationRewrite {
        <MessageRoute_DestinationRewrite as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_DestinationRewrite {
    pub fn new() -> MessageRoute_DestinationRewrite {
        ::std::default::Default::default()
    }

    // .messaging.Address newAddress = 1;


    pub fn get_newAddress(&self) -> &Address {
        self.newAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_newAddress(&mut self) {
        self.newAddress.clear();
    }

    pub fn has_newAddress(&self) -> bool {
        self.newAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newAddress(&mut self, v: Address) {
        self.newAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newAddress(&mut self) -> &mut Address {
        if self.newAddress.is_none() {
            self.newAddress.set_default();
        }
        self.newAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_newAddress(&mut self) -> Address {
        self.newAddress.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for MessageRoute_DestinationRewrite {
    fn is_initialized(&self) -> bool {
        for v in &self.newAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.newAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.newAddress.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_DestinationRewrite {
        MessageRoute_DestinationRewrite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "newAddress",
                    |m: &MessageRoute_DestinationRewrite| { &m.newAddress },
                    |m: &mut MessageRoute_DestinationRewrite| { &mut m.newAddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_DestinationRewrite>(
                    "MessageRoute.DestinationRewrite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_DestinationRewrite {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_DestinationRewrite> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_DestinationRewrite::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_DestinationRewrite {
    fn clear(&mut self) {
        self.newAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_DestinationRewrite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_DestinationRewrite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_ThenDo {
    // message fields
    pub firstRoute: ::protobuf::SingularPtrField<MessageRoute>,
    pub onOk: ::protobuf::SingularPtrField<MessageRoute>,
    pub onReject: ::protobuf::SingularPtrField<MessageRoute>,
    pub onError: ::protobuf::SingularPtrField<MessageRoute>,
    pub onSuspend: ::protobuf::SingularPtrField<MessageRoute>,
    pub onTimeout: ::protobuf::SingularPtrField<MessageRoute>,
    pub onAckTimeout: ::protobuf::SingularPtrField<MessageRoute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_ThenDo {
    fn default() -> &'a MessageRoute_ThenDo {
        <MessageRoute_ThenDo as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_ThenDo {
    pub fn new() -> MessageRoute_ThenDo {
        ::std::default::Default::default()
    }

    // .messaging.MessageRoute firstRoute = 1;


    pub fn get_firstRoute(&self) -> &MessageRoute {
        self.firstRoute.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_firstRoute(&mut self) {
        self.firstRoute.clear();
    }

    pub fn has_firstRoute(&self) -> bool {
        self.firstRoute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstRoute(&mut self, v: MessageRoute) {
        self.firstRoute = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstRoute(&mut self) -> &mut MessageRoute {
        if self.firstRoute.is_none() {
            self.firstRoute.set_default();
        }
        self.firstRoute.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstRoute(&mut self) -> MessageRoute {
        self.firstRoute.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onOk = 2;


    pub fn get_onOk(&self) -> &MessageRoute {
        self.onOk.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onOk(&mut self) {
        self.onOk.clear();
    }

    pub fn has_onOk(&self) -> bool {
        self.onOk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onOk(&mut self, v: MessageRoute) {
        self.onOk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onOk(&mut self) -> &mut MessageRoute {
        if self.onOk.is_none() {
            self.onOk.set_default();
        }
        self.onOk.as_mut().unwrap()
    }

    // Take field
    pub fn take_onOk(&mut self) -> MessageRoute {
        self.onOk.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onReject = 3;


    pub fn get_onReject(&self) -> &MessageRoute {
        self.onReject.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onReject(&mut self) {
        self.onReject.clear();
    }

    pub fn has_onReject(&self) -> bool {
        self.onReject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onReject(&mut self, v: MessageRoute) {
        self.onReject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onReject(&mut self) -> &mut MessageRoute {
        if self.onReject.is_none() {
            self.onReject.set_default();
        }
        self.onReject.as_mut().unwrap()
    }

    // Take field
    pub fn take_onReject(&mut self) -> MessageRoute {
        self.onReject.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onError = 4;


    pub fn get_onError(&self) -> &MessageRoute {
        self.onError.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onError(&mut self) {
        self.onError.clear();
    }

    pub fn has_onError(&self) -> bool {
        self.onError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onError(&mut self, v: MessageRoute) {
        self.onError = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onError(&mut self) -> &mut MessageRoute {
        if self.onError.is_none() {
            self.onError.set_default();
        }
        self.onError.as_mut().unwrap()
    }

    // Take field
    pub fn take_onError(&mut self) -> MessageRoute {
        self.onError.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onSuspend = 5;


    pub fn get_onSuspend(&self) -> &MessageRoute {
        self.onSuspend.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onSuspend(&mut self) {
        self.onSuspend.clear();
    }

    pub fn has_onSuspend(&self) -> bool {
        self.onSuspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onSuspend(&mut self, v: MessageRoute) {
        self.onSuspend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onSuspend(&mut self) -> &mut MessageRoute {
        if self.onSuspend.is_none() {
            self.onSuspend.set_default();
        }
        self.onSuspend.as_mut().unwrap()
    }

    // Take field
    pub fn take_onSuspend(&mut self) -> MessageRoute {
        self.onSuspend.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onTimeout = 6;


    pub fn get_onTimeout(&self) -> &MessageRoute {
        self.onTimeout.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onTimeout(&mut self) {
        self.onTimeout.clear();
    }

    pub fn has_onTimeout(&self) -> bool {
        self.onTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onTimeout(&mut self, v: MessageRoute) {
        self.onTimeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onTimeout(&mut self) -> &mut MessageRoute {
        if self.onTimeout.is_none() {
            self.onTimeout.set_default();
        }
        self.onTimeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_onTimeout(&mut self) -> MessageRoute {
        self.onTimeout.take().unwrap_or_else(|| MessageRoute::new())
    }

    // .messaging.MessageRoute onAckTimeout = 7;


    pub fn get_onAckTimeout(&self) -> &MessageRoute {
        self.onAckTimeout.as_ref().unwrap_or_else(|| MessageRoute::default_instance())
    }
    pub fn clear_onAckTimeout(&mut self) {
        self.onAckTimeout.clear();
    }

    pub fn has_onAckTimeout(&self) -> bool {
        self.onAckTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onAckTimeout(&mut self, v: MessageRoute) {
        self.onAckTimeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onAckTimeout(&mut self) -> &mut MessageRoute {
        if self.onAckTimeout.is_none() {
            self.onAckTimeout.set_default();
        }
        self.onAckTimeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_onAckTimeout(&mut self) -> MessageRoute {
        self.onAckTimeout.take().unwrap_or_else(|| MessageRoute::new())
    }
}

impl ::protobuf::Message for MessageRoute_ThenDo {
    fn is_initialized(&self) -> bool {
        for v in &self.firstRoute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onOk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onReject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onError {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onSuspend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onTimeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.onAckTimeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.firstRoute)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onOk)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onReject)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onError)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onSuspend)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onTimeout)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.onAckTimeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.firstRoute.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onOk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onReject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onError.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onSuspend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onTimeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.onAckTimeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.firstRoute.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onOk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onReject.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onError.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onSuspend.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onTimeout.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.onAckTimeout.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_ThenDo {
        MessageRoute_ThenDo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "firstRoute",
                    |m: &MessageRoute_ThenDo| { &m.firstRoute },
                    |m: &mut MessageRoute_ThenDo| { &mut m.firstRoute },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onOk",
                    |m: &MessageRoute_ThenDo| { &m.onOk },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onOk },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onReject",
                    |m: &MessageRoute_ThenDo| { &m.onReject },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onReject },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onError",
                    |m: &MessageRoute_ThenDo| { &m.onError },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onError },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onSuspend",
                    |m: &MessageRoute_ThenDo| { &m.onSuspend },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onSuspend },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onTimeout",
                    |m: &MessageRoute_ThenDo| { &m.onTimeout },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onTimeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "onAckTimeout",
                    |m: &MessageRoute_ThenDo| { &m.onAckTimeout },
                    |m: &mut MessageRoute_ThenDo| { &mut m.onAckTimeout },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_ThenDo>(
                    "MessageRoute.ThenDo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_ThenDo {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_ThenDo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_ThenDo::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_ThenDo {
    fn clear(&mut self) {
        self.firstRoute.clear();
        self.onOk.clear();
        self.onReject.clear();
        self.onError.clear();
        self.onSuspend.clear();
        self.onTimeout.clear();
        self.onAckTimeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_ThenDo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_ThenDo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_Choice {
    // message fields
    pub condition: ::protobuf::RepeatedField<MessageRoute_Choice_ChoiceCondition>,
    pub route: ::protobuf::RepeatedField<MessageRoute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_Choice {
    fn default() -> &'a MessageRoute_Choice {
        <MessageRoute_Choice as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_Choice {
    pub fn new() -> MessageRoute_Choice {
        ::std::default::Default::default()
    }

    // repeated .messaging.MessageRoute.Choice.ChoiceCondition condition = 1;


    pub fn get_condition(&self) -> &[MessageRoute_Choice_ChoiceCondition] {
        &self.condition
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: ::protobuf::RepeatedField<MessageRoute_Choice_ChoiceCondition>) {
        self.condition = v;
    }

    // Mutable pointer to the field.
    pub fn mut_condition(&mut self) -> &mut ::protobuf::RepeatedField<MessageRoute_Choice_ChoiceCondition> {
        &mut self.condition
    }

    // Take field
    pub fn take_condition(&mut self) -> ::protobuf::RepeatedField<MessageRoute_Choice_ChoiceCondition> {
        ::std::mem::replace(&mut self.condition, ::protobuf::RepeatedField::new())
    }

    // repeated .messaging.MessageRoute route = 2;


    pub fn get_route(&self) -> &[MessageRoute] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<MessageRoute>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<MessageRoute> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<MessageRoute> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessageRoute_Choice {
    fn is_initialized(&self) -> bool {
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.condition)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.condition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.route {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.condition {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.route {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_Choice {
        MessageRoute_Choice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute_Choice_ChoiceCondition>>(
                    "condition",
                    |m: &MessageRoute_Choice| { &m.condition },
                    |m: &mut MessageRoute_Choice| { &mut m.condition },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "route",
                    |m: &MessageRoute_Choice| { &m.route },
                    |m: &mut MessageRoute_Choice| { &mut m.route },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_Choice>(
                    "MessageRoute.Choice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_Choice {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_Choice> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_Choice::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_Choice {
    fn clear(&mut self) {
        self.condition.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_Choice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_Choice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_Choice_ChoiceCondition {
    // message oneof groups
    pub alt: ::std::option::Option<MessageRoute_Choice_ChoiceCondition_oneof_alt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_Choice_ChoiceCondition {
    fn default() -> &'a MessageRoute_Choice_ChoiceCondition {
        <MessageRoute_Choice_ChoiceCondition as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MessageRoute_Choice_ChoiceCondition_oneof_alt {
    destinationInternationalRegexp(::std::string::String),
    destinationNationalRegexp(::std::string::String),
    destinationTextRegexp(::std::string::String),
    catchAll(bool),
    destinationUnknownRegexp(::std::string::String),
}

impl MessageRoute_Choice_ChoiceCondition {
    pub fn new() -> MessageRoute_Choice_ChoiceCondition {
        ::std::default::Default::default()
    }

    // string destinationInternationalRegexp = 1;


    pub fn get_destinationInternationalRegexp(&self) -> &str {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_destinationInternationalRegexp(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_destinationInternationalRegexp(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destinationInternationalRegexp(&mut self, v: ::std::string::String) {
        self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destinationInternationalRegexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(_)) = self.alt {
        } else {
            self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(::std::string::String::new()));
        }
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destinationInternationalRegexp(&mut self) -> ::std::string::String {
        if self.has_destinationInternationalRegexp() {
            match self.alt.take() {
                ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string destinationNationalRegexp = 2;


    pub fn get_destinationNationalRegexp(&self) -> &str {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_destinationNationalRegexp(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_destinationNationalRegexp(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destinationNationalRegexp(&mut self, v: ::std::string::String) {
        self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destinationNationalRegexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(_)) = self.alt {
        } else {
            self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(::std::string::String::new()));
        }
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destinationNationalRegexp(&mut self) -> ::std::string::String {
        if self.has_destinationNationalRegexp() {
            match self.alt.take() {
                ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string destinationTextRegexp = 3;


    pub fn get_destinationTextRegexp(&self) -> &str {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_destinationTextRegexp(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_destinationTextRegexp(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destinationTextRegexp(&mut self, v: ::std::string::String) {
        self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destinationTextRegexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(_)) = self.alt {
        } else {
            self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(::std::string::String::new()));
        }
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destinationTextRegexp(&mut self) -> ::std::string::String {
        if self.has_destinationTextRegexp() {
            match self.alt.take() {
                ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool catchAll = 4;


    pub fn get_catchAll(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(v)) => v,
            _ => false,
        }
    }
    pub fn clear_catchAll(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_catchAll(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_catchAll(&mut self, v: bool) {
        self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(v))
    }

    // string destinationUnknownRegexp = 5;


    pub fn get_destinationUnknownRegexp(&self) -> &str {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_destinationUnknownRegexp(&mut self) {
        self.alt = ::std::option::Option::None;
    }

    pub fn has_destinationUnknownRegexp(&self) -> bool {
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destinationUnknownRegexp(&mut self, v: ::std::string::String) {
        self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destinationUnknownRegexp(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(_)) = self.alt {
        } else {
            self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(::std::string::String::new()));
        }
        match self.alt {
            ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destinationUnknownRegexp(&mut self) -> ::std::string::String {
        if self.has_destinationUnknownRegexp() {
            match self.alt.take() {
                ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for MessageRoute_Choice_ChoiceCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(is.read_bool()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.alt = ::std::option::Option::Some(MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.alt {
            match v {
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(v) => {
                    my_size += 2;
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.alt {
            match v {
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationInternationalRegexp(ref v) => {
                    os.write_string(1, v)?;
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationNationalRegexp(ref v) => {
                    os.write_string(2, v)?;
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationTextRegexp(ref v) => {
                    os.write_string(3, v)?;
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::catchAll(v) => {
                    os.write_bool(4, v)?;
                },
                &MessageRoute_Choice_ChoiceCondition_oneof_alt::destinationUnknownRegexp(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_Choice_ChoiceCondition {
        MessageRoute_Choice_ChoiceCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "destinationInternationalRegexp",
                    MessageRoute_Choice_ChoiceCondition::has_destinationInternationalRegexp,
                    MessageRoute_Choice_ChoiceCondition::get_destinationInternationalRegexp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "destinationNationalRegexp",
                    MessageRoute_Choice_ChoiceCondition::has_destinationNationalRegexp,
                    MessageRoute_Choice_ChoiceCondition::get_destinationNationalRegexp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "destinationTextRegexp",
                    MessageRoute_Choice_ChoiceCondition::has_destinationTextRegexp,
                    MessageRoute_Choice_ChoiceCondition::get_destinationTextRegexp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "catchAll",
                    MessageRoute_Choice_ChoiceCondition::has_catchAll,
                    MessageRoute_Choice_ChoiceCondition::get_catchAll,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "destinationUnknownRegexp",
                    MessageRoute_Choice_ChoiceCondition::has_destinationUnknownRegexp,
                    MessageRoute_Choice_ChoiceCondition::get_destinationUnknownRegexp,
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_Choice_ChoiceCondition>(
                    "MessageRoute.Choice.ChoiceCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_Choice_ChoiceCondition {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_Choice_ChoiceCondition> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_Choice_ChoiceCondition::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_Choice_ChoiceCondition {
    fn clear(&mut self) {
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.alt = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_Choice_ChoiceCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_Choice_ChoiceCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageRoute_Fork {
    // message fields
    pub route: ::protobuf::RepeatedField<MessageRoute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageRoute_Fork {
    fn default() -> &'a MessageRoute_Fork {
        <MessageRoute_Fork as ::protobuf::Message>::default_instance()
    }
}

impl MessageRoute_Fork {
    pub fn new() -> MessageRoute_Fork {
        ::std::default::Default::default()
    }

    // repeated .messaging.MessageRoute route = 1;


    pub fn get_route(&self) -> &[MessageRoute] {
        &self.route
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: ::protobuf::RepeatedField<MessageRoute>) {
        self.route = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut ::protobuf::RepeatedField<MessageRoute> {
        &mut self.route
    }

    // Take field
    pub fn take_route(&mut self) -> ::protobuf::RepeatedField<MessageRoute> {
        ::std::mem::replace(&mut self.route, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessageRoute_Fork {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.route {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.route {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageRoute_Fork {
        MessageRoute_Fork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MessageRoute>>(
                    "route",
                    |m: &MessageRoute_Fork| { &m.route },
                    |m: &mut MessageRoute_Fork| { &mut m.route },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageRoute_Fork>(
                    "MessageRoute.Fork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageRoute_Fork {
        static mut instance: ::protobuf::lazy::Lazy<MessageRoute_Fork> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(MessageRoute_Fork::new)
        }
    }
}

impl ::protobuf::Clear for MessageRoute_Fork {
    fn clear(&mut self) {
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageRoute_Fork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageRoute_Fork {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmsFragmentedContent {
    // message fields
    pub of: i32,
    pub udhi: bool,
    pub fragments: ::protobuf::RepeatedField<SmsFragment>,
    pub protocolIdentifier: i32,
    pub reportStatus: bool,
    pub sendDate: u64,
    pub messageClass: SmsFragmentedContent_MessageClass,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmsFragmentedContent {
    fn default() -> &'a SmsFragmentedContent {
        <SmsFragmentedContent as ::protobuf::Message>::default_instance()
    }
}

impl SmsFragmentedContent {
    pub fn new() -> SmsFragmentedContent {
        ::std::default::Default::default()
    }

    // int32 of = 1;


    pub fn get_of(&self) -> i32 {
        self.of
    }
    pub fn clear_of(&mut self) {
        self.of = 0;
    }

    // Param is passed by value, moved
    pub fn set_of(&mut self, v: i32) {
        self.of = v;
    }

    // bool udhi = 2;


    pub fn get_udhi(&self) -> bool {
        self.udhi
    }
    pub fn clear_udhi(&mut self) {
        self.udhi = false;
    }

    // Param is passed by value, moved
    pub fn set_udhi(&mut self, v: bool) {
        self.udhi = v;
    }

    // repeated .messaging.SmsFragment fragments = 3;


    pub fn get_fragments(&self) -> &[SmsFragment] {
        &self.fragments
    }
    pub fn clear_fragments(&mut self) {
        self.fragments.clear();
    }

    // Param is passed by value, moved
    pub fn set_fragments(&mut self, v: ::protobuf::RepeatedField<SmsFragment>) {
        self.fragments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fragments(&mut self) -> &mut ::protobuf::RepeatedField<SmsFragment> {
        &mut self.fragments
    }

    // Take field
    pub fn take_fragments(&mut self) -> ::protobuf::RepeatedField<SmsFragment> {
        ::std::mem::replace(&mut self.fragments, ::protobuf::RepeatedField::new())
    }

    // int32 protocolIdentifier = 4;


    pub fn get_protocolIdentifier(&self) -> i32 {
        self.protocolIdentifier
    }
    pub fn clear_protocolIdentifier(&mut self) {
        self.protocolIdentifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_protocolIdentifier(&mut self, v: i32) {
        self.protocolIdentifier = v;
    }

    // bool reportStatus = 5;


    pub fn get_reportStatus(&self) -> bool {
        self.reportStatus
    }
    pub fn clear_reportStatus(&mut self) {
        self.reportStatus = false;
    }

    // Param is passed by value, moved
    pub fn set_reportStatus(&mut self, v: bool) {
        self.reportStatus = v;
    }

    // uint64 sendDate = 6;


    pub fn get_sendDate(&self) -> u64 {
        self.sendDate
    }
    pub fn clear_sendDate(&mut self) {
        self.sendDate = 0;
    }

    // Param is passed by value, moved
    pub fn set_sendDate(&mut self, v: u64) {
        self.sendDate = v;
    }

    // .messaging.SmsFragmentedContent.MessageClass messageClass = 7;


    pub fn get_messageClass(&self) -> SmsFragmentedContent_MessageClass {
        self.messageClass
    }
    pub fn clear_messageClass(&mut self) {
        self.messageClass = SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_messageClass(&mut self, v: SmsFragmentedContent_MessageClass) {
        self.messageClass = v;
    }
}

impl ::protobuf::Message for SmsFragmentedContent {
    fn is_initialized(&self) -> bool {
        for v in &self.fragments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.of = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.udhi = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fragments)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.protocolIdentifier = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reportStatus = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sendDate = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.messageClass, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.of != 0 {
            my_size += ::protobuf::rt::value_size(1, self.of, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.udhi != false {
            my_size += 2;
        }
        for value in &self.fragments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.protocolIdentifier != 0 {
            my_size += ::protobuf::rt::value_size(4, self.protocolIdentifier, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reportStatus != false {
            my_size += 2;
        }
        if self.sendDate != 0 {
            my_size += ::protobuf::rt::value_size(6, self.sendDate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.messageClass != SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET {
            my_size += ::protobuf::rt::enum_size(7, self.messageClass);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.of != 0 {
            os.write_int32(1, self.of)?;
        }
        if self.udhi != false {
            os.write_bool(2, self.udhi)?;
        }
        for v in &self.fragments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.protocolIdentifier != 0 {
            os.write_int32(4, self.protocolIdentifier)?;
        }
        if self.reportStatus != false {
            os.write_bool(5, self.reportStatus)?;
        }
        if self.sendDate != 0 {
            os.write_uint64(6, self.sendDate)?;
        }
        if self.messageClass != SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET {
            os.write_enum(7, self.messageClass.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmsFragmentedContent {
        SmsFragmentedContent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "of",
                    |m: &SmsFragmentedContent| { &m.of },
                    |m: &mut SmsFragmentedContent| { &mut m.of },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "udhi",
                    |m: &SmsFragmentedContent| { &m.udhi },
                    |m: &mut SmsFragmentedContent| { &mut m.udhi },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmsFragment>>(
                    "fragments",
                    |m: &SmsFragmentedContent| { &m.fragments },
                    |m: &mut SmsFragmentedContent| { &mut m.fragments },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "protocolIdentifier",
                    |m: &SmsFragmentedContent| { &m.protocolIdentifier },
                    |m: &mut SmsFragmentedContent| { &mut m.protocolIdentifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reportStatus",
                    |m: &SmsFragmentedContent| { &m.reportStatus },
                    |m: &mut SmsFragmentedContent| { &mut m.reportStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "sendDate",
                    |m: &SmsFragmentedContent| { &m.sendDate },
                    |m: &mut SmsFragmentedContent| { &mut m.sendDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SmsFragmentedContent_MessageClass>>(
                    "messageClass",
                    |m: &SmsFragmentedContent| { &m.messageClass },
                    |m: &mut SmsFragmentedContent| { &mut m.messageClass },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmsFragmentedContent>(
                    "SmsFragmentedContent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmsFragmentedContent {
        static mut instance: ::protobuf::lazy::Lazy<SmsFragmentedContent> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SmsFragmentedContent::new)
        }
    }
}

impl ::protobuf::Clear for SmsFragmentedContent {
    fn clear(&mut self) {
        self.of = 0;
        self.udhi = false;
        self.fragments.clear();
        self.protocolIdentifier = 0;
        self.reportStatus = false;
        self.sendDate = 0;
        self.messageClass = SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmsFragmentedContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsFragmentedContent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SmsFragmentedContent_MessageClass {
    MESSAGE_CLASS_NOT_SET = 0,
    UNSPECIFIED = 1,
    CLASS0 = 2,
    CLASS1 = 3,
    CLASS2 = 4,
    CLASS3 = 5,
}

impl ::protobuf::ProtobufEnum for SmsFragmentedContent_MessageClass {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmsFragmentedContent_MessageClass> {
        match value {
            0 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET),
            1 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::UNSPECIFIED),
            2 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::CLASS0),
            3 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::CLASS1),
            4 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::CLASS2),
            5 => ::std::option::Option::Some(SmsFragmentedContent_MessageClass::CLASS3),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SmsFragmentedContent_MessageClass] = &[
            SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET,
            SmsFragmentedContent_MessageClass::UNSPECIFIED,
            SmsFragmentedContent_MessageClass::CLASS0,
            SmsFragmentedContent_MessageClass::CLASS1,
            SmsFragmentedContent_MessageClass::CLASS2,
            SmsFragmentedContent_MessageClass::CLASS3,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SmsFragmentedContent_MessageClass>("SmsFragmentedContent.MessageClass", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SmsFragmentedContent_MessageClass {
}

impl ::std::default::Default for SmsFragmentedContent_MessageClass {
    fn default() -> Self {
        SmsFragmentedContent_MessageClass::MESSAGE_CLASS_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsFragmentedContent_MessageClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SmsFragment {
    // message fields
    pub part: i32,
    pub content: ::std::vec::Vec<u8>,
    pub encoding: Charset,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmsFragment {
    fn default() -> &'a SmsFragment {
        <SmsFragment as ::protobuf::Message>::default_instance()
    }
}

impl SmsFragment {
    pub fn new() -> SmsFragment {
        ::std::default::Default::default()
    }

    // int32 part = 1;


    pub fn get_part(&self) -> i32 {
        self.part
    }
    pub fn clear_part(&mut self) {
        self.part = 0;
    }

    // Param is passed by value, moved
    pub fn set_part(&mut self, v: i32) {
        self.part = v;
    }

    // bytes content = 2;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }

    // .messaging.Charset encoding = 3;


    pub fn get_encoding(&self) -> Charset {
        self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding = Charset::CHARSET_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: Charset) {
        self.encoding = v;
    }
}

impl ::protobuf::Message for SmsFragment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.part = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.part != 0 {
            my_size += ::protobuf::rt::value_size(1, self.part, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        if self.encoding != Charset::CHARSET_NOT_SET {
            my_size += ::protobuf::rt::enum_size(3, self.encoding);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.part != 0 {
            os.write_int32(1, self.part)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        if self.encoding != Charset::CHARSET_NOT_SET {
            os.write_enum(3, self.encoding.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmsFragment {
        SmsFragment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "part",
                    |m: &SmsFragment| { &m.part },
                    |m: &mut SmsFragment| { &mut m.part },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "content",
                    |m: &SmsFragment| { &m.content },
                    |m: &mut SmsFragment| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Charset>>(
                    "encoding",
                    |m: &SmsFragment| { &m.encoding },
                    |m: &mut SmsFragment| { &mut m.encoding },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmsFragment>(
                    "SmsFragment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SmsFragment {
        static mut instance: ::protobuf::lazy::Lazy<SmsFragment> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SmsFragment::new)
        }
    }
}

impl ::protobuf::Clear for SmsFragment {
    fn clear(&mut self) {
        self.part = 0;
        self.content.clear();
        self.encoding = Charset::CHARSET_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmsFragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmsFragment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextMessage {
    // message fields
    pub messageId: i64,
    pub body: ::std::string::String,
    pub fromAddress: ::protobuf::SingularPtrField<Address>,
    pub toAddress: ::protobuf::SingularPtrField<Address>,
    pub direction: Direction,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextMessage {
    fn default() -> &'a TextMessage {
        <TextMessage as ::protobuf::Message>::default_instance()
    }
}

impl TextMessage {
    pub fn new() -> TextMessage {
        ::std::default::Default::default()
    }

    // int64 messageId = 1;


    pub fn get_messageId(&self) -> i64 {
        self.messageId
    }
    pub fn clear_messageId(&mut self) {
        self.messageId = 0;
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = v;
    }

    // string body = 2;


    pub fn get_body(&self) -> &str {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body, ::std::string::String::new())
    }

    // .messaging.Address fromAddress = 3;


    pub fn get_fromAddress(&self) -> &Address {
        self.fromAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_fromAddress(&mut self) {
        self.fromAddress.clear();
    }

    pub fn has_fromAddress(&self) -> bool {
        self.fromAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromAddress(&mut self, v: Address) {
        self.fromAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromAddress(&mut self) -> &mut Address {
        if self.fromAddress.is_none() {
            self.fromAddress.set_default();
        }
        self.fromAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromAddress(&mut self) -> Address {
        self.fromAddress.take().unwrap_or_else(|| Address::new())
    }

    // .messaging.Address toAddress = 4;


    pub fn get_toAddress(&self) -> &Address {
        self.toAddress.as_ref().unwrap_or_else(|| Address::default_instance())
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    pub fn has_toAddress(&self) -> bool {
        self.toAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: Address) {
        self.toAddress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut Address {
        if self.toAddress.is_none() {
            self.toAddress.set_default();
        }
        self.toAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_toAddress(&mut self) -> Address {
        self.toAddress.take().unwrap_or_else(|| Address::new())
    }

    // .messaging.Direction direction = 5;


    pub fn get_direction(&self) -> Direction {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = Direction::DIRECTION_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: Direction) {
        self.direction = v;
    }
}

impl ::protobuf::Message for TextMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.fromAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.toAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.messageId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fromAddress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.toAddress)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.messageId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.messageId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.body);
        }
        if let Some(ref v) = self.fromAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.toAddress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != Direction::DIRECTION_NOT_SET {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.messageId != 0 {
            os.write_int64(1, self.messageId)?;
        }
        if !self.body.is_empty() {
            os.write_string(2, &self.body)?;
        }
        if let Some(ref v) = self.fromAddress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.toAddress.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != Direction::DIRECTION_NOT_SET {
            os.write_enum(5, self.direction.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextMessage {
        TextMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "messageId",
                    |m: &TextMessage| { &m.messageId },
                    |m: &mut TextMessage| { &mut m.messageId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    |m: &TextMessage| { &m.body },
                    |m: &mut TextMessage| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "fromAddress",
                    |m: &TextMessage| { &m.fromAddress },
                    |m: &mut TextMessage| { &mut m.fromAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                    "toAddress",
                    |m: &TextMessage| { &m.toAddress },
                    |m: &mut TextMessage| { &mut m.toAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                    "direction",
                    |m: &TextMessage| { &m.direction },
                    |m: &mut TextMessage| { &mut m.direction },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextMessage>(
                    "TextMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TextMessage {
        static mut instance: ::protobuf::lazy::Lazy<TextMessage> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TextMessage::new)
        }
    }
}

impl ::protobuf::Clear for TextMessage {
    fn clear(&mut self) {
        self.messageId = 0;
        self.body.clear();
        self.fromAddress.clear();
        self.toAddress.clear();
        self.direction = Direction::DIRECTION_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendResult {
    // message fields
    pub messageId: i64,
    pub status: SendAttemptStatus,
    pub description: ::std::string::String,
    pub uuid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendResult {
    fn default() -> &'a SendResult {
        <SendResult as ::protobuf::Message>::default_instance()
    }
}

impl SendResult {
    pub fn new() -> SendResult {
        ::std::default::Default::default()
    }

    // int64 messageId = 1;


    pub fn get_messageId(&self) -> i64 {
        self.messageId
    }
    pub fn clear_messageId(&mut self) {
        self.messageId = 0;
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = v;
    }

    // .messaging.SendAttemptStatus status = 2;


    pub fn get_status(&self) -> SendAttemptStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SendAttemptStatus) {
        self.status = v;
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string uuid = 4;


    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.messageId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.messageId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.messageId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.messageId != 0 {
            os.write_int64(1, self.messageId)?;
        }
        if self.status != SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET {
            os.write_enum(2, self.status.value())?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(4, &self.uuid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendResult {
        SendResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "messageId",
                    |m: &SendResult| { &m.messageId },
                    |m: &mut SendResult| { &mut m.messageId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SendAttemptStatus>>(
                    "status",
                    |m: &SendResult| { &m.status },
                    |m: &mut SendResult| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &SendResult| { &m.description },
                    |m: &mut SendResult| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uuid",
                    |m: &SendResult| { &m.uuid },
                    |m: &mut SendResult| { &mut m.uuid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendResult>(
                    "SendResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendResult {
        static mut instance: ::protobuf::lazy::Lazy<SendResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SendResult::new)
        }
    }
}

impl ::protobuf::Clear for SendResult {
    fn clear(&mut self) {
        self.messageId = 0;
        self.status = SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET;
        self.description.clear();
        self.uuid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReceiveStatus {
    // message fields
    pub messageId: i64,
    pub status: ReceiveAttemptStatus,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveStatus {
    fn default() -> &'a ReceiveStatus {
        <ReceiveStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveStatus {
    pub fn new() -> ReceiveStatus {
        ::std::default::Default::default()
    }

    // int64 messageId = 1;


    pub fn get_messageId(&self) -> i64 {
        self.messageId
    }
    pub fn clear_messageId(&mut self) {
        self.messageId = 0;
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = v;
    }

    // .messaging.ReceiveAttemptStatus status = 2;


    pub fn get_status(&self) -> ReceiveAttemptStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReceiveAttemptStatus) {
        self.status = v;
    }

    // string description = 3;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReceiveStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.messageId = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.messageId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.messageId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.messageId != 0 {
            os.write_int64(1, self.messageId)?;
        }
        if self.status != ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET {
            os.write_enum(2, self.status.value())?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveStatus {
        ReceiveStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "messageId",
                    |m: &ReceiveStatus| { &m.messageId },
                    |m: &mut ReceiveStatus| { &mut m.messageId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReceiveAttemptStatus>>(
                    "status",
                    |m: &ReceiveStatus| { &m.status },
                    |m: &mut ReceiveStatus| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &ReceiveStatus| { &m.description },
                    |m: &mut ReceiveStatus| { &mut m.description },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveStatus>(
                    "ReceiveStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReceiveStatus {
        static mut instance: ::protobuf::lazy::Lazy<ReceiveStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReceiveStatus::new)
        }
    }
}

impl ::protobuf::Clear for ReceiveStatus {
    fn clear(&mut self) {
        self.messageId = 0;
        self.status = ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsuspendResult {
    // message fields
    pub status: UnsuspendStatus,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsuspendResult {
    fn default() -> &'a UnsuspendResult {
        <UnsuspendResult as ::protobuf::Message>::default_instance()
    }
}

impl UnsuspendResult {
    pub fn new() -> UnsuspendResult {
        ::std::default::Default::default()
    }

    // .messaging.UnsuspendStatus status = 1;


    pub fn get_status(&self) -> UnsuspendStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UnsuspendStatus) {
        self.status = v;
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnsuspendResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET {
            os.write_enum(1, self.status.value())?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsuspendResult {
        UnsuspendResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnsuspendStatus>>(
                    "status",
                    |m: &UnsuspendResult| { &m.status },
                    |m: &mut UnsuspendResult| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &UnsuspendResult| { &m.description },
                    |m: &mut UnsuspendResult| { &mut m.description },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnsuspendResult>(
                    "UnsuspendResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnsuspendResult {
        static mut instance: ::protobuf::lazy::Lazy<UnsuspendResult> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UnsuspendResult::new)
        }
    }
}

impl ::protobuf::Clear for UnsuspendResult {
    fn clear(&mut self) {
        self.status = UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET;
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsuspendResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsuspendResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Direction {
    DIRECTION_NOT_SET = 0,
    INCOMING = 1,
    OUTGOING = 2,
}

impl ::protobuf::ProtobufEnum for Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::DIRECTION_NOT_SET),
            1 => ::std::option::Option::Some(Direction::INCOMING),
            2 => ::std::option::Option::Some(Direction::OUTGOING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Direction] = &[
            Direction::DIRECTION_NOT_SET,
            Direction::INCOMING,
            Direction::OUTGOING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Direction>("Direction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Direction {
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::DIRECTION_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Charset {
    CHARSET_NOT_SET = 0,
    UNKNOWN = 1,
    GSM7 = 2,
    GSM8 = 3,
    UCS2 = 4,
    ISO_8859_1 = 5,
}

impl ::protobuf::ProtobufEnum for Charset {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Charset> {
        match value {
            0 => ::std::option::Option::Some(Charset::CHARSET_NOT_SET),
            1 => ::std::option::Option::Some(Charset::UNKNOWN),
            2 => ::std::option::Option::Some(Charset::GSM7),
            3 => ::std::option::Option::Some(Charset::GSM8),
            4 => ::std::option::Option::Some(Charset::UCS2),
            5 => ::std::option::Option::Some(Charset::ISO_8859_1),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Charset] = &[
            Charset::CHARSET_NOT_SET,
            Charset::UNKNOWN,
            Charset::GSM7,
            Charset::GSM8,
            Charset::UCS2,
            Charset::ISO_8859_1,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Charset>("Charset", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Charset {
}

impl ::std::default::Default for Charset {
    fn default() -> Self {
        Charset::CHARSET_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for Charset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SendAttemptStatus {
    SEND_ATTEMPT_STATUS_NOT_SET = 0,
    SEND_OK = 1,
    SEND_REJECT = 2,
    SEND_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for SendAttemptStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SendAttemptStatus> {
        match value {
            0 => ::std::option::Option::Some(SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET),
            1 => ::std::option::Option::Some(SendAttemptStatus::SEND_OK),
            2 => ::std::option::Option::Some(SendAttemptStatus::SEND_REJECT),
            3 => ::std::option::Option::Some(SendAttemptStatus::SEND_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SendAttemptStatus] = &[
            SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET,
            SendAttemptStatus::SEND_OK,
            SendAttemptStatus::SEND_REJECT,
            SendAttemptStatus::SEND_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<SendAttemptStatus>("SendAttemptStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SendAttemptStatus {
}

impl ::std::default::Default for SendAttemptStatus {
    fn default() -> Self {
        SendAttemptStatus::SEND_ATTEMPT_STATUS_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for SendAttemptStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReceiveAttemptStatus {
    RECEIVE_ATTEMPT_STATUS_NOT_SET = 0,
    RECEIVE_OK = 1,
    RECEIVE_REJECT = 2,
    RECEIVE_ERROR = 3,
    RECEIVE_SUSPEND = 4,
    RECEIVE_TIMEOUT = 5,
    RECEIVE_ACK_TIMEOUT = 6,
    RECEIVE_INTERCEPT = 7,
    RECEIVE_UPDATE = 8,
}

impl ::protobuf::ProtobufEnum for ReceiveAttemptStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReceiveAttemptStatus> {
        match value {
            0 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET),
            1 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_OK),
            2 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_REJECT),
            3 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_ERROR),
            4 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_SUSPEND),
            5 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_TIMEOUT),
            6 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_ACK_TIMEOUT),
            7 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_INTERCEPT),
            8 => ::std::option::Option::Some(ReceiveAttemptStatus::RECEIVE_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReceiveAttemptStatus] = &[
            ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET,
            ReceiveAttemptStatus::RECEIVE_OK,
            ReceiveAttemptStatus::RECEIVE_REJECT,
            ReceiveAttemptStatus::RECEIVE_ERROR,
            ReceiveAttemptStatus::RECEIVE_SUSPEND,
            ReceiveAttemptStatus::RECEIVE_TIMEOUT,
            ReceiveAttemptStatus::RECEIVE_ACK_TIMEOUT,
            ReceiveAttemptStatus::RECEIVE_INTERCEPT,
            ReceiveAttemptStatus::RECEIVE_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReceiveAttemptStatus>("ReceiveAttemptStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReceiveAttemptStatus {
}

impl ::std::default::Default for ReceiveAttemptStatus {
    fn default() -> Self {
        ReceiveAttemptStatus::RECEIVE_ATTEMPT_STATUS_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveAttemptStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UnsuspendStatus {
    UNSUSPEND_STATUS_NOT_SET = 0,
    UNSUSPEND_OK = 1,
    UNSUSPEND_REJECT = 2,
    UNSUSPEND_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for UnsuspendStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UnsuspendStatus> {
        match value {
            0 => ::std::option::Option::Some(UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET),
            1 => ::std::option::Option::Some(UnsuspendStatus::UNSUSPEND_OK),
            2 => ::std::option::Option::Some(UnsuspendStatus::UNSUSPEND_REJECT),
            3 => ::std::option::Option::Some(UnsuspendStatus::UNSUSPEND_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UnsuspendStatus] = &[
            UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET,
            UnsuspendStatus::UNSUSPEND_OK,
            UnsuspendStatus::UNSUSPEND_REJECT,
            UnsuspendStatus::UNSUSPEND_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<UnsuspendStatus>("UnsuspendStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UnsuspendStatus {
}

impl ::std::default::Default for UnsuspendStatus {
    fn default() -> Self {
        UnsuspendStatus::UNSUSPEND_STATUS_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsuspendStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11messagecore.proto\x12\tmessaging\"\x18\n\x16ReceiveMessagesRequest\
    \"\x1c\n\x1aReceiveTextMessagesRequest\"\xd0\x01\n\x12AckMessageResponse\
    \x12]\n\x11ackResponseStatus\x18\x01\x20\x01(\x0e2/.messaging.AckMessage\
    Response.AckResponseStatusR\x11ackResponseStatus\x12\"\n\x0cerrorMessage\
    \x18\x02\x20\x01(\tR\x0cerrorMessage\"7\n\x11AckResponseStatus\x12\x10\n\
    \x0cACK_ACCEPTED\x10\0\x12\x10\n\x0cACK_REJECTED\x10\x01\"\x87\x01\n\x11\
    AckMessageRequest\x126\n\tackStatus\x18\x01\x20\x01(\x0b2\x18.messaging.\
    ReceiveStatusR\tackStatus\x12:\n\x0eupdatedMessage\x18\x02\x20\x01(\x0b2\
    \x12.messaging.MessageR\x0eupdatedMessage\"\xd2\x01\n\x07Address\x12+\n\
    \x04type\x18\x01\x20\x01(\x0e2\x17.messaging.Address.TypeR\x04type\x12\
    \x16\n\x06number\x18\x02\x20\x01(\tR\x06number\"\x81\x01\n\x04Type\x12\
    \x10\n\x0cTYPE_NOT_SET\x10\0\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x18\n\x14I\
    NTERNATIONAL_NUMBER\x10\x02\x12\x13\n\x0fNATIONAL_NUMBER\x10\x03\x12\x08\
    \n\x04TEXT\x10\x04\x12\t\n\x05EMAIL\x10\x05\x12\x08\n\x04IMSI\x10\x06\
    \x12\x0c\n\x08RESERVED\x10\x07\"\x83\x02\n\nMessageBox\x122\n\nforAddres\
    s\x18\x01\x20\x01(\x0b2\x12.messaging.AddressR\nforAddress\x12@\n\tdirec\
    tion\x18\x02\x20\x01(\x0e2\".messaging.MessageBox.BoxDirectionR\tdirecti\
    on\x12.\n\x08messages\x18\x03\x20\x03(\x0b2\x12.messaging.MessageR\x08me\
    ssages\"O\n\x0cBoxDirection\x12\x19\n\x15BOX_DIRECTION_NOT_SET\x10\0\x12\
    \x0c\n\x08INCOMING\x10\x01\x12\x0c\n\x08OUTGOING\x10\x02\x12\x08\n\x04BO\
    TH\x10\x03\"\x80\x01\n\x0eTextMessageBox\x122\n\nforAddress\x18\x01\x20\
    \x01(\x0b2\x12.messaging.AddressR\nforAddress\x12:\n\x0ctextMessages\x18\
    \x03\x20\x03(\x0b2\x16.messaging.TextMessageR\x0ctextMessages\"\xcf\x05\
    \n\x07Message\x12\x1c\n\tmessageId\x18\x01\x20\x01(\x03R\tmessageId\x12=\
    \n\tfragments\x18\x02\x20\x01(\x0b2\x1f.messaging.SmsFragmentedContentR\
    \tfragments\x124\n\x0bfromAddress\x18\x03\x20\x01(\x0b2\x12.messaging.Ad\
    dressR\x0bfromAddress\x120\n\ttoAddress\x18\x04\x20\x01(\x0b2\x12.messag\
    ing.AddressR\ttoAddress\x122\n\tdirection\x18\x05\x20\x01(\x0e2\x14.mess\
    aging.DirectionR\tdirection\x12\x18\n\x07expires\x18\x06\x20\x01(\x04R\
    \x07expires\x12\x1a\n\x08producer\x18\x07\x20\x01(\tR\x08producer\x12$\n\
    \rsendTimestamp\x18\t\x20\x01(\x04R\rsendTimestamp\x12-\n\x05route\x18\n\
    \x20\x01(\x0b2\x17.messaging.MessageRouteR\x05route\x12C\n\x0croutingSta\
    te\x18\x0b\x20\x03(\x0b2\x1f.messaging.Message.RoutingStateR\x0croutingS\
    tate\x12\x12\n\x04uuid\x18\x0c\x20\x01(\tR\x04uuid\x12@\n\x11originNetwo\
    rkNode\x18\r\x20\x01(\x0b2\x12.messaging.AddressR\x11originNetworkNode\
    \x1a\xa4\x01\n\x0cRoutingState\x12I\n\x0ereceiveAttempt\x18\x01\x20\x01(\
    \x0e2\x1f.messaging.ReceiveAttemptStatusH\0R\x0ereceiveAttempt\x12\"\n\
    \x0btakenChoice\x18\x02\x20\x01(\x11H\0R\x0btakenChoice\x12\x1e\n\ttaken\
    Fork\x18\x03\x20\x01(\x11H\0R\ttakenForkB\x05\n\x03alt\"\xac\x0f\n\x0cMe\
    ssageRoute\x12F\n\trejecting\x18\x01\x20\x01(\x0b2&.messaging.MessageRou\
    te.RejectingRouteH\0R\trejecting\x12C\n\x08retrying\x18\x02\x20\x01(\x0b\
    2%.messaging.MessageRoute.RetryingRouteH\0R\x08retrying\x12=\n\x06static\
    \x18\x03\x20\x01(\x0b2#.messaging.MessageRoute.StaticRouteH\0R\x06static\
    \x12\\\n\x12destinationRewrite\x18\x04\x20\x01(\x0b2*.messaging.MessageR\
    oute.DestinationRewriteH\0R\x12destinationRewrite\x128\n\x06thenDo\x18\
    \x05\x20\x01(\x0b2\x1e.messaging.MessageRoute.ThenDoH\0R\x06thenDo\x128\
    \n\x06choice\x18\x06\x20\x01(\x0b2\x1e.messaging.MessageRoute.ChoiceH\0R\
    \x06choice\x122\n\x04fork\x18\x07\x20\x01(\x0b2\x1c.messaging.MessageRou\
    te.ForkH\0R\x04fork\x1a\x10\n\x0eRejectingRoute\x1a\x95\x03\n\rRetryingR\
    oute\x123\n\x08subRoute\x18\x01\x20\x01(\x0b2\x17.messaging.MessageRoute\
    R\x08subRoute\x124\n\x15maxAttemptsBeforeFail\x18\x02\x20\x01(\x05R\x15m\
    axAttemptsBeforeFail\x12[\n\x0cerrorBackoff\x18\x03\x20\x01(\x0b27.messa\
    ging.MessageRoute.RetryingRoute.BackoffParametersR\x0cerrorBackoff\x12E\
    \n\rerrorsToRetry\x18\x04\x20\x03(\x0e2\x1f.messaging.ReceiveAttemptStat\
    usR\rerrorsToRetry\x1au\n\x11BackoffParameters\x126\n\x16backoffInterval\
    Seconds\x18\x01\x20\x01(\x05R\x16backoffIntervalSeconds\x12(\n\x0fmaxBac\
    koffPower\x18\x02\x20\x01(\x05R\x0fmaxBackoffPower\x1aQ\n\x0bStaticRoute\
    \x12\x1a\n\x08consumer\x18\x01\x20\x01(\tR\x08consumer\x12&\n\x0ereceive\
    Timeout\x18\x02\x20\x01(\x05R\x0ereceiveTimeout\x1aH\n\x12DestinationRew\
    rite\x122\n\nnewAddress\x18\x01\x20\x01(\x0b2\x12.messaging.AddressR\nne\
    wAddress\x1a\x81\x03\n\x06ThenDo\x127\n\nfirstRoute\x18\x01\x20\x01(\x0b\
    2\x17.messaging.MessageRouteR\nfirstRoute\x12+\n\x04onOk\x18\x02\x20\x01\
    (\x0b2\x17.messaging.MessageRouteR\x04onOk\x123\n\x08onReject\x18\x03\
    \x20\x01(\x0b2\x17.messaging.MessageRouteR\x08onReject\x121\n\x07onError\
    \x18\x04\x20\x01(\x0b2\x17.messaging.MessageRouteR\x07onError\x125\n\ton\
    Suspend\x18\x05\x20\x01(\x0b2\x17.messaging.MessageRouteR\tonSuspend\x12\
    5\n\tonTimeout\x18\x06\x20\x01(\x0b2\x17.messaging.MessageRouteR\tonTime\
    out\x12;\n\x0conAckTimeout\x18\x07\x20\x01(\x0b2\x17.messaging.MessageRo\
    uteR\x0conAckTimeout\x1a\xbe\x03\n\x06Choice\x12L\n\tcondition\x18\x01\
    \x20\x03(\x0b2..messaging.MessageRoute.Choice.ChoiceConditionR\tconditio\
    n\x12-\n\x05route\x18\x02\x20\x03(\x0b2\x17.messaging.MessageRouteR\x05r\
    oute\x1a\xb6\x02\n\x0fChoiceCondition\x12H\n\x1edestinationInternational\
    Regexp\x18\x01\x20\x01(\tH\0R\x1edestinationInternationalRegexp\x12>\n\
    \x19destinationNationalRegexp\x18\x02\x20\x01(\tH\0R\x19destinationNatio\
    nalRegexp\x126\n\x15destinationTextRegexp\x18\x03\x20\x01(\tH\0R\x15dest\
    inationTextRegexp\x12\x1c\n\x08catchAll\x18\x04\x20\x01(\x08H\0R\x08catc\
    hAll\x12<\n\x18destinationUnknownRegexp\x18\x05\x20\x01(\tH\0R\x18destin\
    ationUnknownRegexpB\x05\n\x03alt\x1a5\n\x04Fork\x12-\n\x05route\x18\x01\
    \x20\x03(\x0b2\x17.messaging.MessageRouteR\x05routeB\x07\n\x05route\"\
    \x9e\x03\n\x14SmsFragmentedContent\x12\x0e\n\x02of\x18\x01\x20\x01(\x05R\
    \x02of\x12\x12\n\x04udhi\x18\x02\x20\x01(\x08R\x04udhi\x124\n\tfragments\
    \x18\x03\x20\x03(\x0b2\x16.messaging.SmsFragmentR\tfragments\x12.\n\x12p\
    rotocolIdentifier\x18\x04\x20\x01(\x05R\x12protocolIdentifier\x12\"\n\
    \x0creportStatus\x18\x05\x20\x01(\x08R\x0creportStatus\x12\x1a\n\x08send\
    Date\x18\x06\x20\x01(\x04R\x08sendDate\x12P\n\x0cmessageClass\x18\x07\
    \x20\x01(\x0e2,.messaging.SmsFragmentedContent.MessageClassR\x0cmessageC\
    lass\"j\n\x0cMessageClass\x12\x19\n\x15MESSAGE_CLASS_NOT_SET\x10\0\x12\
    \x0f\n\x0bUNSPECIFIED\x10\x01\x12\n\n\x06CLASS0\x10\x02\x12\n\n\x06CLASS\
    1\x10\x03\x12\n\n\x06CLASS2\x10\x04\x12\n\n\x06CLASS3\x10\x05\"k\n\x0bSm\
    sFragment\x12\x12\n\x04part\x18\x01\x20\x01(\x05R\x04part\x12\x18\n\x07c\
    ontent\x18\x02\x20\x01(\x0cR\x07content\x12.\n\x08encoding\x18\x03\x20\
    \x01(\x0e2\x12.messaging.CharsetR\x08encoding\"\xdb\x01\n\x0bTextMessage\
    \x12\x1c\n\tmessageId\x18\x01\x20\x01(\x03R\tmessageId\x12\x12\n\x04body\
    \x18\x02\x20\x01(\tR\x04body\x124\n\x0bfromAddress\x18\x03\x20\x01(\x0b2\
    \x12.messaging.AddressR\x0bfromAddress\x120\n\ttoAddress\x18\x04\x20\x01\
    (\x0b2\x12.messaging.AddressR\ttoAddress\x122\n\tdirection\x18\x05\x20\
    \x01(\x0e2\x14.messaging.DirectionR\tdirection\"\x96\x01\n\nSendResult\
    \x12\x1c\n\tmessageId\x18\x01\x20\x01(\x03R\tmessageId\x124\n\x06status\
    \x18\x02\x20\x01(\x0e2\x1c.messaging.SendAttemptStatusR\x06status\x12\
    \x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\x12\n\x04uu\
    id\x18\x04\x20\x01(\tR\x04uuid\"\x88\x01\n\rReceiveStatus\x12\x1c\n\tmes\
    sageId\x18\x01\x20\x01(\x03R\tmessageId\x127\n\x06status\x18\x02\x20\x01\
    (\x0e2\x1f.messaging.ReceiveAttemptStatusR\x06status\x12\x20\n\x0bdescri\
    ption\x18\x03\x20\x01(\tR\x0bdescription\"g\n\x0fUnsuspendResult\x122\n\
    \x06status\x18\x01\x20\x01(\x0e2\x1a.messaging.UnsuspendStatusR\x06statu\
    s\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription*>\n\tDirec\
    tion\x12\x15\n\x11DIRECTION_NOT_SET\x10\0\x12\x0c\n\x08INCOMING\x10\x01\
    \x12\x0c\n\x08OUTGOING\x10\x02*Y\n\x07Charset\x12\x13\n\x0fCHARSET_NOT_S\
    ET\x10\0\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x08\n\x04GSM7\x10\x02\x12\x08\
    \n\x04GSM8\x10\x03\x12\x08\n\x04UCS2\x10\x04\x12\x0e\n\nISO_8859_1\x10\
    \x05*b\n\x11SendAttemptStatus\x12\x1f\n\x1bSEND_ATTEMPT_STATUS_NOT_SET\
    \x10\0\x12\x0b\n\x07SEND_OK\x10\x01\x12\x0f\n\x0bSEND_REJECT\x10\x02\x12\
    \x0e\n\nSEND_ERROR\x10\x03*\xdf\x01\n\x14ReceiveAttemptStatus\x12\"\n\
    \x1eRECEIVE_ATTEMPT_STATUS_NOT_SET\x10\0\x12\x0e\n\nRECEIVE_OK\x10\x01\
    \x12\x12\n\x0eRECEIVE_REJECT\x10\x02\x12\x11\n\rRECEIVE_ERROR\x10\x03\
    \x12\x13\n\x0fRECEIVE_SUSPEND\x10\x04\x12\x13\n\x0fRECEIVE_TIMEOUT\x10\
    \x05\x12\x17\n\x13RECEIVE_ACK_TIMEOUT\x10\x06\x12\x15\n\x11RECEIVE_INTER\
    CEPT\x10\x07\x12\x12\n\x0eRECEIVE_UPDATE\x10\x08*l\n\x0fUnsuspendStatus\
    \x12\x1c\n\x18UNSUSPEND_STATUS_NOT_SET\x10\0\x12\x10\n\x0cUNSUSPEND_OK\
    \x10\x01\x12\x14\n\x10UNSUSPEND_REJECT\x10\x02\x12\x13\n\x0fUNSUSPEND_ER\
    ROR\x10\x032\xce\x03\n\x0bMessageCore\x12:\n\x0bSendMessage\x12\x12.mess\
    aging.Message\x1a\x15.messaging.SendResult\"\0\x12B\n\x0fSendTextMessage\
    \x12\x16.messaging.TextMessage\x1a\x15.messaging.SendResult\"\0\x12O\n\
    \x0fReceiveMessages\x12!.messaging.ReceiveMessagesRequest\x1a\x15.messag\
    ing.MessageBox\"\00\x01\x12[\n\x13ReceiveTextMessages\x12%.messaging.Rec\
    eiveTextMessagesRequest\x1a\x19.messaging.TextMessageBox\"\00\x01\x12K\n\
    \nAckMessage\x12\x1c.messaging.AckMessageRequest\x1a\x1d.messaging.AckMe\
    ssageResponse\"\0\x12D\n\x10UnsuspendAddress\x12\x12.messaging.Address\
    \x1a\x1a.messaging.UnsuspendResult\"\0B\x20\n\x1eio.omnicate.messaging.p\
    rotobufb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
